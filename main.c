#include <stdio.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>
#include <stm32f10x_tim.h>
#include <stm32f10x.h>
#include <misc.h>
#include <stm32f10x_usart.h>
#include "servo_control.h"

/**
 * Application that interacts with the HC-SR04 ultrasonic
 * sensor and transmits the measured pulse width over USART1
 * once per second. The distance needs to be processed on the
 * client side.
 */

#define START_BYTE			0xFA
#define STOP_BYTE			0XFB

// Members
int led_state = 0;
static __IO uint32_t TimingDelay;
static int TxPrimed = 0;
uint8_t distance_and_angle[5] = {START_BYTE, 0, 0, 0, STOP_BYTE};

// Function prototypes
static void init_HC_SR04();
static void init_gpio();
static void init_usart();
static void send_data(uint16_t);
static void toggleInternalLEDs();
static void delay(uint32_t time);
static void init_timer2();
static uint16_t HC_SR04_read();

int main(void)
{
	// Tick every ms
	SysTick_Config(SystemCoreClock / 1000);

	init_HC_SR04();
	delay(1000);

	while(1)
	{
		send_data(HC_SR04_read());
		toggle_servo();
		delay(1000);
	}
}

static void init_HC_SR04()
{
	init_gpio();
	init_timer2();
	servo_control_init();
	init_usart();
}

/**
 * Configure GPIO pins
 */
static void init_gpio()
{
	// PB6 -----> TIM4_CH1
	// PA8 -----> TIM1_CH1

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA
			| RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);

	GPIO_InitTypeDef GPIO_InitTypeStructure;

	// Trigger pin
	GPIO_InitTypeStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_InitTypeStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitTypeStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOC, &GPIO_InitTypeStructure);

	// Echo pin
	GPIO_InitTypeStructure.GPIO_Pin = GPIO_Pin_7;
	GPIO_InitTypeStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_InitTypeStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOC, &GPIO_InitTypeStructure);

	// USART1_Tx
	GPIO_InitTypeStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitTypeStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitTypeStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitTypeStructure);

	// USART1_Rx
	GPIO_InitTypeStructure.GPIO_Pin = GPIO_Pin_10;
	GPIO_InitTypeStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOA, &GPIO_InitTypeStructure);

	//Internal LEDs
	GPIO_InitTypeStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
	GPIO_InitTypeStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitTypeStructure.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_Init(GPIOC, &GPIO_InitTypeStructure);

	GPIO_ResetBits(GPIOC, GPIO_Pin_6);
}

static void init_timer2(void) {

	TIM_TimeBaseInitTypeDef   TIM_TimeBaseStructure;
	TIM_OCInitTypeDef         TIM_OCInitStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_OCStructInit(&TIM_OCInitStructure);

	TIM_TimeBaseStructure.TIM_Period = 65535 - 1;
	TIM_TimeBaseStructure.TIM_Prescaler = (uint16_t) (SystemCoreClock / 1000000) - 1;
	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	TIM_Cmd(TIM2, ENABLE);
}

/**
 * Return the pulse width of the signal generated by the HC-SR04.
 * This is easily converted to centimeters on the client side
 * by multiplying the value by 0.01715 and add 0.8 (which is the offset
 * from the drive unit to the surrounding hardware of the ultrasonic sensor).
 */
static uint16_t HC_SR04_read(void) {
	toggleInternalLEDs();

	TIM_SetCounter(TIM2, 0);

	// Send a 15us pulse to the HC-SR04
	GPIO_SetBits(GPIOC, GPIO_Pin_6);
	while(TIM_GetCounter(TIM2) < 15);
	GPIO_ResetBits(GPIOC, GPIO_Pin_6);

	// Read the pulse width returned by the HC-SR04
	while(!GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7));
	TIM_SetCounter(TIM2, 0);
	while(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7));

	// Pulse width of signal
	return TIM_GetCounter(TIM2);
}

static void init_usart()
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);

	USART_InitTypeDef USART_InitStructure;
	// Initialize USART structure
	USART_StructInit(&USART_InitStructure);

	USART_InitStructure.USART_BaudRate = 9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_Mode = USART_Mode_Tx;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;

	USART_Init(USART1, &USART_InitStructure);

	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable the USART1 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	USART_Cmd(USART1, ENABLE);
}

void USART1_IRQHandler(void)
{
	static int tx_index = 0;

	if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
	{
		USART_SendData(USART1, distance_and_angle[tx_index++]);

		if (tx_index >= (sizeof(distance_and_angle)))
		{
			tx_index = 0;
			USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
		}
	}
}

/**
 * Split the the uint16_t in two before sending.
 * They will need to be put together on the client
 * side by reversing this operation:
 * --> uint16_t value = low | high << 8;
 */
static void send_data(uint16_t d)
{
	// The lower 8 bits
	distance_and_angle[1] = d & 0xFF;
	// The higher 8 bits
	distance_and_angle[2] = d >> 8;

	distance_and_angle[3] = get_servo_pos();

	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
}

static void toggleInternalLEDs()
{
	GPIO_WriteBit(GPIOC, GPIO_Pin_8, led_state ? Bit_RESET : Bit_SET);
	GPIO_WriteBit(GPIOC, GPIO_Pin_9, led_state ? Bit_RESET : Bit_SET);
	led_state = !led_state;
}

/**
 * Sleep for a given amount of milliseconds
 */
static void delay(uint32_t time)
{
	TimingDelay = time;
	while(TimingDelay != 0);
}

void SysTick_Handler()
{
	if (TimingDelay != 0x00)
		TimingDelay--;
}
